# -*- coding: utf-8 -*-
"""Sna_final_matrix and playlist ranking

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hnk9WzPM_mgkyM_yalaO0kSYo-FPFVBa

This Python script reads in TED Talk data, creates a directed graph based on the tags associated with each talk, and recommends a playlist of talks based on a seed tag. The recommended talks are selected based on their tags' similarity to the seed tag, and they are ranked by view count to ensure that the most popular talks are selected for the playlist.
"""

import pandas as pd
import ast
import networkx as nx
import random

# read the tags from the csv file
df = pd.read_csv('TED_Talk1.csv')

# drop rows with NaN values in the 'talks_tags' column
df = df.dropna(subset=['talks_tags'])

# create an empty directed graph
G = nx.DiGraph()

# add nodes to the graph for each unique tag
for tags in df['talks_tags']:
    if isinstance(tags, str):
        tags_list = ast.literal_eval(tags)
        for tag in tags_list:
            G.add_node(tag)

# add edges based on shared tags
for tags in df['talks_tags']:
    if isinstance(tags, str):
        tags_list = ast.literal_eval(tags)
        for i in range(len(tags_list)-1):
            for j in range(i+1, len(tags_list)):
                G.add_edge(tags_list[i], tags_list[j])

# Define the seed tag for the playlist
seed_tag = 'education'

# Find the neighborhood of the seed tag
neighborhood = set(G.neighbors(seed_tag))

# Find the TED Talks that are tagged with at least one tag in the neighborhood
recommended_talks = []
for index, row in df.iterrows():
    talk_tags = ast.literal_eval(row['talks_tags'])
    if len(set(talk_tags).intersection(neighborhood)) > 0:
        recommended_talks.append(row)

# Rank the recommended talks by view count
ranked_talks = sorted(recommended_talks, key=lambda x: x['view_count'], reverse=True)

# Select the top talks for the playlist
playlist = [talk['talk__name'] for talk in ranked_talks[:10]]

print("\n\n")
print("Recommendeded TED Talks playlist based on the tag:", seed_tag)
for talk in playlist:
    print(talk)

print("\n\n")

"""Using faker we generate users' views and try to use that to improve the previous recommendations."""

pip install Faker

import pandas as pd
import numpy as np
import random

TED_Talk1 = pd.read_csv('TED_Talk1.csv')

# Generating user views for each talk
users = ['user_' + str(i) for i in range(1, 11)]
user_views = []
for i in range(len(TED_Talk1)):
    user_dict = {}
    for user in users:
        if random.random() < 0.5:
            user_dict[user] = 0
        else:
            user_dict[user] = round(random.uniform(0.1, 1), 2)
    user_views.append(user_dict)

# Adding the new column to the Ted Talk dataset
TED_Talk1['user_views'] = user_views

TED_Talk1.to_csv('TED_Talk1_with_user_views.csv', index=False)

"""The recommended talks are selected based on their tags' similarity to the seed tag, and they are ranked by the average user views to ensure that the most engaging talks are selected for the playlist."""

import pandas as pd
import ast
import networkx as nx
import random

# read the tags and user views from the csv file
df = pd.read_csv('TED_Talk1_with_user_views.csv')

# drop rows with NaN values in the 'talks_tags' and 'user_views' columns
df = df.dropna(subset=['talks_tags', 'user_views'])

# create an empty directed graph
G = nx.DiGraph()

# add nodes to the graph for each unique tag
for tags in df['talks_tags']:
  try:
    if isinstance(tags, str):
        tags_list = ast.literal_eval(tags)
        for tag in tags_list:
            G.add_node(tag)
  except:
    continue

# add edges based on shared tags
for tags in df['talks_tags']:
  try:
    if isinstance(tags, str):
        tags_list = ast.literal_eval(tags)
        for i in range(len(tags_list)-1):
            for j in range(i+1, len(tags_list)):
                G.add_edge(tags_list[i], tags_list[j])
  except:
    continue

# Define the seed tag for the playlist
seed_tag = 'education'

# Find the neighborhood of the seed tag
neighborhood = set(G.neighbors(seed_tag))

# Find the TED Talks that are tagged with at least one tag in the neighborhood
recommended_talks = []
for index, row in df.iterrows():
  try:
    talk_tags = ast.literal_eval(row['talks_tags'])
    if len(set(talk_tags).intersection(neighborhood)) > 0:
        recommended_talks.append(row)
  except:
    continue

# Rank the recommended talks by average user views
ranked_talks = []
for talk in recommended_talks:
  try:
    views_dict = ast.literal_eval(talk['user_views'])
    avg_views = sum(views_dict.values()) / len(views_dict)
    talk['avg_views'] = avg_views
    ranked_talks.append(talk)
  except:
    continue

ranked_talks = sorted(ranked_talks, key=lambda x: x['avg_views'], reverse=True)

# Select the top talks for the playlist
playlist = [talk['talk__name'] for talk in ranked_talks[:10]]

print("\n\n")
print("Recommended TED Talks playlist based on the tag:", seed_tag)
for talk in playlist:
    print(talk)

print("\n\n")